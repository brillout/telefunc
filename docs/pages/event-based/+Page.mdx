import { Link } from '@brillout/docpress'

With REST or GraphQL, API endpoints are:

- Generic
- Backend-owned (defined and implemented by the backend team)

With Telefunc, it's usually the opposite — telefunctions are typically:

- Tailored
- Frontend-owned (defined and implemented by the frontend team)

This inversion leads to a significantly faster development speed.

You may be tempted to create generic telefunctions out of habit from working with REST or GraphQL, but this is usually an anti-pattern as shown in the example below. Instead, we recommend implementing what we call *event-based* telefunctions.


## Example

Imagine an existing to-do list app, and the product team requests a new feature: add a new button `Mark all tasks as completed`.

With a RESTful API, the app would typically do this:

```shell
HTTP            URL                                           PAYLOAD
=========       =========================================     =====================
# Make a request to fetch all non-completed tasks
GET             https://api.todo.com/task?completed=false     ∅
# Make a request per task to update it
POST            https://api.todo.com/task/42                  { "completed": true }
POST            https://api.todo.com/task/1337                { "completed": true }
POST            https://api.todo.com/task/7                   { "completed": true }
```

> With REST, it's usually the backend team that is responsible for defining and implementing the API.

{/*
Couldn't find a reference to link to:
- Wikipedia doens't have an article about the N+1 problem
- https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping
  - But it refers to ORMs and not REST
- https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance
  - Convoluted
- Drizze doens't have any docs about the N+1 problem
- Anyways, I feel like uses nowadays don't care much about these theoretical concepts anymore
*/}
This is inefficient as it makes a lot of HTTP requests (the infamous `N+1` problem).

With Telefunc, you can do this instead:

```ts
// components/TodoList.telefunc.ts
// Environment: server

import { Tasks } from '../data/Tasks'

export async function onMarkAllAsCompleted() {
  // With an ORM
  await Tasks.update({ completed: true  }).where({ completed: false })

  // Or with SQL
  await sql('UPDATE tasks SET completed = true WHERE completed = false')
}
```

> With Telefunc, it's usually the frontend team that is responsible for defining and implementing telefunctions.

The telefunction `onMarkAllAsCompleted()` is created specifically to serve the needs of the component `TodoList.tsx`, whereas a RESTful API is a set of generic endpoints agnostic to your frontend.

Not only is it more performant, but it's also faster to implement. You can implement telefunctions hand-in-hand with your frontend development, instead of having to implement an entire RESTful API before even getting started with your frontend development.

Thus, in general, we recommend implementing telefunctions that are tailored instead of generic.

We recommend naming telefunctions `onSomeEvent()` since they are typically triggered by some kind of event.

```shell
components/TodoList.tsx
# Co-locating the component's telefunctions
components/TodoList.telefunc.ts
```

```tsx
// components/TodoList.tsx
// Environment: client

import { onMarkAllAsCompleted } from './TodoList.telefunc.ts'

function TodoList() {
  return <>
    {/* ... */}
    <button onClick={onMarkAllAsCompleted}>
      Mark all as completed
    </button>
  </>
}
```


## Naming convention

As explained above, we recommend creating tailored telefunctions (instead of generic ones).

For a crystal-clear structure, we recommend naming telefunctions `onSomeEvent()`.

```bash
    TELEFUNCTIONS
    =============
❌  updateTodo() # generic telefunction
✅  onTodoTextUpdate() # tailored telefunction
✅  onTodoComplete() # tailored telefunction

❌  loadData()
✅  onLoad()
✅  onPagination()
✅  onInfiniteScroll()
```

We also recommend to co-locate `.telefunc.js` files next to UI component files.

```shell
    FILES
    =====
    components/TodoItem.tsx
✅  components/TodoItem.telefunc.ts
❌  db/todo.telefunc.ts

    components/User.vue
✅  components/User.telefunc.js
❌  db/user/getLoggedInUser.telefunc.js
```

Telefunc displays a warning when the naming convention isn't followed. You can remove the warning with <Link text={<code>config.disableNamingConvention</code>} href="/disableNamingConvention" />.

> Not following the naming convention is perfectly fine, though we recommend having a clear reason for breaking the rule. [Feel free to reach out](https://github.com/brillout/telefunc/issues/new) if you are hesitant (we'll improve this page).


## Exception: several clients

If your telefunctions are used by multiple clients, it can make sense to define a few generic telefunctions that cover all clients, instead of creating different telefunctions for each client.

> Alternatively, you can deploy one Telefunc server per client to preserve the fast development speed of tailored telefunctions.
