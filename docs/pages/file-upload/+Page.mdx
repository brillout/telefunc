Telefunc natively supports [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) and [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) arguments — just pass them to a telefunction like any other argument. Any signature works: single file, multiple files, `File[]` arrays, mixed with other arguments — it's completely transparent.

When a telefunction call contains files, Telefunc automatically switches from JSON to [`multipart/form-data`](https://developer.mozilla.org/en-US/docs/Web/API/FormData). No configuration needed.

## Example

```ts
// upload.telefunc.ts

import fs from 'node:fs'

export async function onUpload(file: File, description: string) {
  // Stream to disk — constant memory, no matter the file size
  const writable = fs.createWriteStream(`./uploads/${file.name}`)
  for await (const chunk of file.stream()) {
    writable.write(chunk)
  }
  writable.end()

  console.log(`Saved ${file.name} (${file.size} bytes): ${description}`)
}
```

```tsx
// Upload.tsx

import { onUpload } from './upload.telefunc'

function UploadForm() {
  return (
    <form
      onSubmit={async (e) => {
        e.preventDefault()
        const form = new FormData(e.currentTarget)
        const file = form.get('file') as File
        const description = form.get('description') as string
        await onUpload(file, description)
      }}
    >
      <input name="file" type="file" />
      <input name="description" type="text" placeholder="Description" />
      <button type="submit">Upload</button>
    </form>
  )
}
```

## How it works

Telefunc uses a custom streaming multipart parser — files are **not** buffered into memory on the server.

1. The client serializes the telefunction call into a `multipart/form-data` request. File/Blob arguments are replaced with placeholder descriptors and sent as separate binary parts.
2. On the server, Telefunc parses the metadata first, then creates lazy `File`/`Blob` objects that **reference the HTTP body stream** without reading it yet.
3. When your telefunction calls `file.stream()`, `file.text()`, or `file.arrayBuffer()`, the bytes are pulled directly from the HTTP stream on demand.

This means file bytes only flow through memory **when you read them** — and if you stream to disk, constant memory is used regardless of file size.

## Reading methods

Each file argument is a standard [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) / [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object:

| Method | Memory | Use case |
|---|---|---|
| `file.stream()` | **O(chunk)** — constant | Pipe to disk, S3, etc. |
| `file.arrayBuffer()` | **O(file size)** — full buffer | Process in memory |
| `file.text()` | **O(file size)** — full buffer | Read text content |

## Limitations

**One-shot reads.** Each file can only be read once. Calling `.stream()`, `.text()`, or `.arrayBuffer()` a second time throws an error. If you need the data multiple times, buffer it into a variable first.

**Read in order.** When a telefunction has multiple file arguments, they must be read in the order they appear in the function signature. This is because all files share a single forward-only HTTP stream — reading file2 before file1 causes file1 to be discarded (with a warning).

**No `slice()`.** `file.slice()` is not supported on streaming files. Buffer the content first if you need slicing.

**Sequential streaming.** Multiple files are streamed one after another. You can start both streams concurrently and they will be automatically serialized.

## Server integration

Pass the [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object directly:

```ts
const httpResponse = await telefunc({ request })
```
