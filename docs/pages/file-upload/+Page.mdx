Telefunc supports [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) and [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) arguments — just pass them to a telefunction like any other argument. Any signature works: single file, multiple files, `File[]` arrays, mixed with other arguments — it's completely transparent.

> When a telefunction call contains files, Telefunc automatically switches from JSON to [`multipart/form-data`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

## Example

```ts
// FileUpload.telefunc.ts
// Environment: server

import fs from 'node:fs'

export async function onUpload(file: File, description: string) {
  // Stream to disk — constant memory, no matter the file size
  const writable = fs.createWriteStream(`./uploads/${file.name}`)
  for await (const chunk of file.stream()) {
    writable.write(chunk)
  }
  writable.end()

  console.log(`Saved ${file.name} (${file.size} bytes): ${description}`)
}
```

```tsx
// FileUpload.tsx
// Environment: client

import { onUpload } from './FileUpload.telefunc'

function UploadForm() {
  return (
    <form
      onSubmit={async (e) => {
        e.preventDefault()
        const form = new FormData(e.currentTarget)
        const file = form.get('file') as File
        const description = form.get('description') as string
        await onUpload(file, description)
      }}
    >
      <input name="file" type="file" />
      <input name="description" type="text" placeholder="Description" />
      <button type="submit">Upload</button>
    </form>
  )
}
```

{/* @brillout TODO/after-PR-merge move this section further below */}
## How it works

Telefunc uses a custom streaming multipart parser — files are **not** buffered into memory on the server.

1. The client serializes the telefunction call into a `multipart/form-data` request. File/Blob arguments are replaced with placeholder descriptors and sent as separate binary parts.
2. On the server, Telefunc parses the metadata first, then creates lazy `File`/`Blob` objects that **reference the HTTP body stream** without reading it yet.
3. When your telefunction calls `file.stream()`, `file.text()`, or `file.arrayBuffer()`, the bytes are pulled directly from the HTTP stream on demand.

This means file bytes only flow through memory **when you read them** — and if you stream to disk, constant memory is used regardless of file size.

## Reading strategies

Each file argument is a standard [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) / [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object:

| Method | Memory | Use case |
|---|---|---|
| `file.stream()` | **O(chunk)** — constant | Pipe to disk, S3, etc. |
| `file.arrayBuffer()` | **O(file size)** — full buffer | Process in memory |
| `file.text()` | **O(file size)** — full buffer | Read text content |

## Limitations

> Nothing is buffered internally — file bytes flow directly from the HTTP stream to your code. If you don't read a file argument, its bytes never leave the sender. This zero-buffering design comes with a few inherent trade-offs:

**One-shot reads.** Each file can only be read once. Calling `.stream()`, `.text()`, or `.arrayBuffer()` a second time throws an error — the bytes have already been consumed from the HTTP stream. If you need the data multiple times, buffer it into a variable first.

**Read in order.** When a telefunction has multiple file arguments, they must be consumed in the order they appear in the function signature — all files share a single forward-only HTTP stream, so reading file2 before file1 would require buffering file1 in memory. Reading out of order causes file1 to be discarded (with a warning). You don't need to `await` each file before starting the next — you can kick off reads concurrently (e.g. `Promise.all([file1.text(), file2.text()])`) and they will be automatically serialized in the correct order.

## Server integration

Pass the [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object directly:

```ts
const httpResponse = await telefunc({ request })
```

With Express, Fastify, or any Node.js framework, you can pass the request as a [`Readable`](https://nodejs.org/api/stream.html#readable-streams) stream along with the `Content-Type` header:

```ts
app.all('/_telefunc', async (req, res) => {
  const httpResponse = await telefunc({
    url: req.originalUrl,
    method: req.method,
    readable: req,
    contentType: req.headers['content-type'] || '',
  })
  res.status(httpResponse.statusCode).type(httpResponse.contentType).send(httpResponse.body)
})
```
